      SUBROUTINE accelerate(xvec, wvec, nzeros, pmax, West)
*
*     SIDI_ACCEL: Sidi extrapolation/acceleration for oscillatory integrals
*     using exact zeros.
*
*     IN:
*        xvec(nzeros+1) : DOUBLE PRECISION array of zeros of f(t)
*        wvec(nzeros)   : DOUBLE PRECISION array of integrals over [x_s, x_{s+1}]
*        nzeros         : INTEGER, number of intervals (>=1)
*        pmax           : INTEGER, maximum acceleration order (requested)
*
*     OUT:
*        West           : DOUBLE PRECISION, accelerated integral estimate
*
      IMPLICIT NONE
      DOUBLE PRECISION xvec(200), wvec(200), West
      DOUBLE PRECISION Mmatrix(200, 50)
      DOUBLE PRECISION Nmatrix(200, 50)
      DOUBLE PRECISION denom, sumw, eps, tinyDenom
      INTEGER nzeros, pmax, pmax_use
      INTEGER s, p
      LOGICAL bad

*     Set up
      eps = 1.0d-300         ! treat areas smaller than this as effectively zero
      tinyDenom = 1.0d-16   ! treat denom smaller than this as dangerous
      West = 0.0d00

*     Trivial cases
      IF (nzeros .LE. 0) THEN
         West = 0.0d00
         RETURN
      ENDIF

      IF (nzeros .EQ. 1) THEN
         West = wvec(1)
         RETURN
      ENDIF

*     Ensure we don't exceed Mmatrix second dim (50)
      IF (pmax .GT. nzeros - 1) THEN
         pmax_use = nzeros - 1
      ELSE
         pmax_use = pmax
      ENDIF
      IF (pmax_use .GT. 48) pmax_use = 48   
*     keep pmax_use+1 <= 49 (safe for 50 cols)

*     If unaccelerated sum (fallback)
      sumw = 0.0d00
      DO s = 1, nzeros
         sumw = sumw + wvec(s)
      ENDDO


***   Here is the guts of the actual acceleration algorithm ***
*     Initialize M and N; checks for tiny areas
      bad = .FALSE.
      DO s = 1, nzeros
         Mmatrix(s, 1) = wvec(s)
*        M^{(s)}_0

         IF (DABS(wvec(s)) .LT. eps) THEN
            bad = .TRUE.
         ELSE
            Nmatrix(s,1) = 1.0d00 / wvec(s)
         ENDIF
      ENDDO

      IF (bad) THEN
*        If any interval area is effectively zero, acceleration unreliable
         West = sumw
         RETURN
      ENDIF

*     Acceleration using pmax_use
*      DO p = 1, (pmax_use + 1)
      DO p = 1, pmax_use
         DO s = 1, nzeros - p
            denom = 1.0d00 / xvec(s) - 1.0d00 / xvec(s + p + 1)
*            denom = 1.0d00 / xvec(s) - 1.0d00 / xvec(s + p)
            IF (DABS(denom) .LT. tinyDenom) THEN
               bad = .TRUE.
               EXIT
            ENDIF
            Mmatrix(s, p + 1) = (Mmatrix(s, p) - 
     &                           Mmatrix(s + 1, p)) / denom
            Nmatrix(s, p + 1) = (Nmatrix(s, p) - 
     &                           Nmatrix(s + 1, p)) / denom
         ENDDO
         IF (bad) EXIT
      ENDDO

      IF (bad) THEN
         West = sumw
         RETURN
      ENDIF

*     Final safety on denominator before returning accelerated value
      IF (DABS(Nmatrix(1, pmax_use + 1)) .LT. tinyDenom) THEN
         West = sumw
      ELSE
         West = Mmatrix(1, pmax_use + 1) / Nmatrix(1, pmax_use + 1)
      ENDIF

      RETURN
      END
