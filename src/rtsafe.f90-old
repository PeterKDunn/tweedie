SUBROUTINE rtsafe(i, funcd, xstart, x1, x2, xacc, root)
  ! This function implements the Newton-Raphson method for finding a root of the
  ! function 'funcd' between bounds x1 and x2, starting at xstart. It includes 
  ! a line-search safeguard to ensure x remains within specified bounds (x1 and x2).

  USE tweedie_params_mod, ONLY: Cverbose
  USE ISO_C_BINDING, ONLY: C_INT, C_DOUBLE

  IMPLICIT NONE

  INTERFACE
      SUBROUTINE funcd_signature(i, x, f, df)
      ! Template for the function for which roots are sought.
        USE ISO_C_BINDING, ONLY: C_INT, C_DOUBLE

        IMPLICIT NONE
        INTEGER(C_INT), INTENT(IN)         :: i
        REAL(KIND=C_DOUBLE), INTENT(IN)    :: x
        REAL(KIND=C_DOUBLE), INTENT(OUT)   :: f, df
      END SUBROUTINE funcd_signature
  END INTERFACE

  PROCEDURE(funcd_signature) :: funcd

  INTEGER(C_INT), INTENT(IN)       :: i
  REAL(KIND=C_DOUBLE), INTENT(IN)  :: x1, x2, xstart, xacc
  REAL(KIND=C_DOUBLE), INTENT(OUT) :: root

  INTEGER, PARAMETER    :: JMAX = 500
  INTEGER               :: j
  REAL(KIND=C_DOUBLE)   :: f, df, fl, fh
  REAL(KIND=C_DOUBLE)   :: xl, xh, dx, rtsafeTMP
  REAL(KIND=C_DOUBLE)   :: testtol
  REAL(KIND=C_DOUBLE)   :: halfbracket, maxstep

  ! Initialize
  xl = x1
  xh = x2
  rtsafeTMP = xstart
  

  ! Evaluate function at endpoints
  CALL funcd(i, xl, fl, df)
  CALL funcd(i, xh, fh, df)
WRITE(*,*) "|||| xl, xh", xl, xh
WRITE(*,*) "|||| fl, fh", fl, fh
  ! If xstart is outside the bracket, use midpoint
  IF ( (rtsafeTMP .LT. MIN(x1, x2) ) .OR.  &
       (rtsafeTMP .GT. MAX(x1, x2)) ) THEN
      rtsafeTMP = 0.5_C_DOUBLE * (x1 + x2)
  END IF

  ! Check fl and fh have opposite signs
  IF ( (fl * fh) .GT. 0.0_C_DOUBLE) THEN
    IF (Cverbose) WRITE(*,*) "RTSAFE ERROR: Root not bracketed by x1 and x2"
    root = HUGE(1.0_C_DOUBLE)
    RETURN
  END IF


  ! ENFORCE SIGN CONVENTION (fl < 0 < fh) ***
  ! We only need to swap to ensure the sign convention holds.
  ! The positional order (xl < xh) will be fixed next if necessary.
  IF (fl .GT. 0.0_C_DOUBLE) THEN
    ! Swap xl <-> xh and fl <-> fh
    dx = xl
    xl = xh
    xh = dx
    dx = fl
    fl = fh
    fh = dx
  END IF
  ! This step is necessary because the sign swap (Step 3) does NOT guarantee 
  ! that xl is numerically less than xh. For safe iteration, we need xl < xh.
  IF (xl .GT. xh) THEN
    dx = xl 
    xl = xh 
    xh = dx
    ! DO NOT swap fl/fh again. Their signs are correct for the function values 
    ! now located at the new xl and xh positions.
  END IF
  ! If xstart is outside the bracket, use midpoint
  IF ( (rtsafeTMP .LT. xl) .OR. (rtsafeTMP .GT. xh) ) THEN
    rtsafeTMP = 0.5_C_DOUBLE * (xl + xh)
END IF
 



  ! Main loop
  DO j = 1, JMAX
      ! Evaluate function and derivative at current estimate
      CALL funcd(i, rtsafeTMP, f, df)
!WRITE(*,*)" RTSAFE j=", j
!WRITE(*,*) "d, df =", f, df
      ! Convergence on function value
      IF (ABS(f) .LE. xacc * (1.0_C_DOUBLE + ABS(rtsafeTMP)) ) THEN
        root = rtsafeTMP
        RETURN
      END IF

      ! Compute half-bracket width & limit for step
      halfbracket = 0.5_C_DOUBLE * (xh - xl)
      maxstep = MAX(ABS(rtsafeTMP), 1.0_C_DOUBLE) * xacc  ! relative related scale

      ! Decide whether to use Newton step or bisection:
      ! - if df is too small (relative), or Newton would step outside bracket,
      !   or Newton step would be unreasonably large, THEN use bisection (midpoint)
      IF (ABS(df) .LT. (1.0E-16_C_DOUBLE * (1.0_C_DOUBLE + ABS(f))) ) THEN
          ! derivative effectively zero -> midpoint
          rtsafeTMP = 0.5_C_DOUBLE * (xl + xh)
      ELSE
          ! proposed Newton step
          dx = f / df
          ! Limit Newton step so it does not exceed half the bracket
          IF (ABS(dx) .GT. halfbracket) THEN
              dx = SIGN(halfbracket, dx)
          END IF
          rtsafeTMP = rtsafeTMP - dx
          ! if Newton step jumps outside bracket, fall back to midpoint
          IF ( (rtsafeTMP .LE. xl) .OR. &
               (rtsafeTMP .GE. xh) ) THEN
              rtsafeTMP = 0.5_C_DOUBLE * (xl + xh)
          END IF
      END IF

      ! Evaluate function at accepted point once
      CALL funcd(i, rtsafeTMP, f, df)

      ! Shrink the bracket using the new f
      IF (f .LT. 0.0_C_DOUBLE) THEN
          xl = rtsafeTMP
          fl = f
      ELSE
          xh = rtsafeTMP
          fh = f
      END IF

      ! Convergence based on interval width (relative) or absolute small step
      testtol = 2.0_C_DOUBLE * xacc * (1.0_C_DOUBLE + ABS(rtsafeTMP))
! ADD THESE DEBUG PRINTS BEFORE THE FINAL IF STATEMENT
IF (Cverbose) THEN
!    WRITE(*,*) "RTSAFE CONVERGENCE CHECK:"
!    WRITE(*,*) "  xh, xl =", xh, xl
!    WRITE(*,*) "  New Width (xh - xl) =", xh - xl
!    WRITE(*,*) "  Test Tol =", testtol
END IF
      
      IF ((xh - xl) .LE. testtol) THEN
          root = rtsafeTMP
  WRITE(*,*) "    - rtsafe converged in", j, "iterations"
          RETURN
      END IF

  END DO

  ! If we exit loop without returning, max iterations reached -> return last estimate
  IF (Cverbose) WRITE(*,*) "RTSAFE WARNING: maximum iterations reached without full convergence."
  root = rtsafeTMP

END SUBROUTINE rtsafe
