ptweedie.inversion2 <- function(q, mu, phi,  power ){ 
  # Evaluates the cdf for Tweedie distributions, using Fourier inversion, 
  # for given values of:
  #   q (possibly a vector)
  #   mu, the mean 
  #   phi the dispersion parameter
  #   power,  the Tweedie index parameter
  
  # Peter K Dunn 
  # Created: 08 Feb 2000 
  # Last edit: 16 Sep 2025
  
  y <- q
  cdf <- array( dim = length(y) )
  
  # Error checks
  if ( power < 1) stop("power must be greater than 1.")
  if ( any(phi <= 0) ) stop("phi must be positive.")
  if ( any(y < 0) ) stop("y must be a non-negative vector.")
  if ( any(mu <= 0) ) stop("mu must be positive.")
  if ( length(mu) > 1) {
    if ( length(mu) != length(y) ) stop("mu must be scalar, or the same length as y.")
  } else {
    mu <- array( dim = length(y), mu )
    # A vector of all mu's
  }
  if ( length(phi) > 1) {
    if ( length(phi) != length(y) ) stop("phi must be scalar, or the same length as y.")
  } else {
    phi <- array( dim = length(y), phi )
    # A vector of all phi's
  }
  
  
  #its <- y
  for (i in (1:length(y))) {
    
    # This has been added to avoid an issue with *very* small values of y
    # causing the FORTRAN to die when p>2; 
    # reported by Johann Cuenin 09 July 2013 (earlier, but that was the easiest email I could find about it :->)
    if ( ( power > 2 ) & (y[i] < 1.0e-300) ) {
      ### THE  e-300  IS ARBITRARY!!!!  ###
      # Keep an eye on it; perhaps it needs changing
      
      # That is, y is very small: Use the limit as y->0 as the answer as FORTRAN has difficulty converging
      # I have kept the call to the FORTRAN (and for p>2, of course, the limiting value is 0).
      #  I could have done this differently
      # by redefining very small y as y=0.... but this is better methinks
      cdf[i] <- 0
    } else {
      
      #   cat(power,phi[i], y[i], mu[i], as.integer(exact),"\n")
      tmp <- .Fortran( "twcomputation2",
                       as.double(power),
                       as.double(phi[i]),
                       as.double(y[i]),
                       as.double(mu[i]),
                       as.double(0), # funvalue
                       as.integer(0), # exitstatus
                       as.double(0), # relerr
                       as.integer(0)) # its
      cdf[i] <- tmp[[6]]
    }
  }
  
  cdf
  
}
