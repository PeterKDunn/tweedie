***
*     Author:         Peter Dunn
*     Creation date:  15 February 1999
*     Last revision:  25 Septembeer 2025
*
* IN R, print statements for debugging as follows:
*     call dblepr("The value of y is ",-1, y, 1)
*     call intpr("The value of exact is ",-1, exact, 1)
******************************************************************
** DF-only routines
******************************************************************

      subroutine twcomputation(p, phi, y, mu, exact,
     &              funvalue, exitstatus, relerr, its )

*     Calculates the DF of the log-likelihood function of a 
*     Poisson-gamma distribution by inverting the MGF.
*
*     IN:   p, phi, y, mu, exact
*     OUT:  funvalue, exitstatus, relerr, its

      implicit none
      double precision  p, phi, y, funvalue, mu,
     &                  calclambda, resulta, result,
     &                  result0, relerr, aimrerr,
     &                  lambda
      integer  ier, maxit, iteratn, exitstatus,
     &         its, exact, verbose
      logical  psmall

* VARIABLES:
*    y        : the value at which the function is to be evaluated
*    x        : the range over which the integral is to be integrated; an
*               internal variable; NOT the value at which the function is to be evaluated
*    lambda   : for 1 < p < 2, P(Y = 0) = exp( -lambda )
*    p        : the index (i.e., variance function is V(mu) = mu ^ p)
*    phi      : the dispersion parameter
*    funvalue : the value of the function at the given value of  x
*    bound    : The bound using Chebyshev theorm.
*    exitstatus:  1  if relative error is smaller than wished (aimrerr)
*                -1  if not, but the absolute error is less than aimrerr
*               -10  if neither rel or abs error any good
*    exact    : 1 if the exact zeros acceleration algorithms is used;
*               0 if the approx zeros acceleration algorithm is used.

*     Set defaults
      verbose = 0
      exitstatus = 1
      relerr = 0.0d00
      its = 0
      lambda = 0

      psmall = .FALSE.
      if ( (p .GT. 1.0d00 ) .AND. (p .LT. 2.0d00) ) then
        psmall = .TRUE.
        lambda = calclambda(p, phi, mu)
      endif

*     SPECIAL CASE: if y < 0, return 0
      if ( y .LT. 0.0d00 ) then
        funvalue = 0.0d00
        return
      endif
      
*     SPECIAL CASE: if 1 < p < 2, Pr(Y = 0) = exp( -lambda )
      if ( psmall .AND. (y .EQ. 0.0d00 ) ) then
        funvalue = exp( -lambda )
        return
      endif

*     SET ACCURACY REQUIREMENTS
      maxit = 25
* CHANGE FROM 100      
      aimrerr = 1.0d-10

*     set other parameters
      iteratn = 0
      ier = 0
      resulta = 0.0d00
      result  = 0.0d00
      result0 = 0.5d00
      
      write(*,*) "****************** y ", y


      if ( exact .EQ. 0 ) then
*        Integrate and accelerate using approx zero acceleration algorithm
      write(*,*) "NOTE: APPROX ACCELERATION", exact
         call DFapproxz( p, phi, y, mu, aimrerr, result,
     &                 maxit, ier, exitstatus, relerr, 
     &                 its )
        write(*,*) "END of approx", exact

         if ( psmall ) then
*           Convert from conditional to ordinary DF
            funvalue = ( ( result + result0 )
     &                 * ( 1.0d00 - exp( -lambda ) ) )
     &                   + exp( -lambda )
         elseif ( .NOT.(psmall) ) then
            funvalue = result + result0
         endif
      else
*        Use exact zeros acceleration algorithm
        write(*,*) "ABOUT to use exact", exact
         if ( psmall ) then
*           Poisson-gamma case
            call DFsmallp( p, phi, y, mu, aimrerr, 
     &        resulta, ier, relerr, its, verbose )

*           Now convert from conditional DF to ordinary DF
            funvalue = ( ( resulta + result0 )
     &                   * ( 1.0d00 - exp( -lambda ) ) )
     &                 + exp( -lambda )

         elseif ( .NOT.(psmall) ) then
      write(*,*) "NOTE: EXACT ACCELERATION", exact
      write(*,*) "      using y:", y

             call DFbigp( p, phi, y, mu, aimrerr, 
     &               resulta, maxit, ier, exitstatus, 
     &               relerr, its, verbose )
             funvalue = resulta + result0
        write(*,*) "BEYOND DFbigp", exact

         endif

*        Some tidy-ups
         if ( funvalue .GT. 1.0d00 ) funvalue = 1.0d00
         if ( .NOT.(psmall) ) then
            if ( funvalue .LT. 0.0d00 ) then
               funvalue = 0.0d00
            endif
         else
            if ( funvalue .LT. exp(-lambda) ) then
               funvalue = exp(-lambda)
            endif
         endif
      endif

      return
      end

******************************************************************
******************************************************************
      subroutine DFsmallp( p, phi, y, mu, aimrerr, 
     &               resulta, ier, relerr, its, verbose )
*     Calculates the DF in the case 1 < p < 2.

      double precision  p, phi, y, pi, area, aimrerr, 
     &         lambda, relerr, result, sidit, DFsfzero,
     &         DFfun2,  DFintim, kddasht, flo, fhi,
     &         mmatrix(2, 200), nmatrix(2, 200),
     &         xvec(200), w, wold(3), area0, sumarea,
     &         DFdk, DFsfzero2, mu, calclambda, area1,
     &         largest,smallest, resulta, t0, z0, DFfun,
     &         delta, oldft, deriv1, deriv2, omega, fndst,
     &         tinfl, ft, zold, z1, dt, olddt, tmp,
     &         alpha, a2, oldt, front, top, bot, rek, imk,
     &         IMddk, rl, workvec1, workvec2, lobnd,
     &         hibnd
      integer  m, ier, n, its, ceil, myfloor, wv1, wv2,
     &         tpt, mdirn, boost, flag, its1, verbose,
     &         goflag
      external  DFfun2, DFdk, DFsfzero2, DFintim, 
     &          kddasht, DFsfzero, ceil, myfloor, IMddk, 
     &          DFfun, fndst

*     SET ACCURACY REQUIREMENTS
      largest = 1.0d20
      smallest = 1.0d-20

*     SET OTHER PARAMETERS
      pi = dacos( -1.0d00 )
      wold(1) = 0.0d00
      wold(2) = 0.0d00
      wold(3) = 0.0d00

      m = 0
*     The zero to solve for
      n = 0
*     The turning point we solving for
      deriv2 = mu - y
*     The initial derivative at t=0
      tpt = 1
*     A flag to indicate if turning points found
      tinfl = 0d00
*     Inflection points at these t
      oldft = 0.0d00
*     Last value of Im k(t)
      ft = 0.0d00
*     Current value of Im k(t)
      area = 0.0d00
      area0 = 0.0d00
      area1 = 0.0d00
*     The integrals values
      zold = 0.0d00
*     The previous zero
      z1 = 0.0d00
*     The current zero
      dt = 0.0d00
*     The current location of Im k'(t) = 0
      olddt  = 0.0d00
*     The previous location of Im k'(t) = 0
      its1 = 0
*     The number of iterations until sidi is used

      alpha = ( 2.0d00 - p ) / ( 1.0d00 - p )
      lambda = calclambda(p, phi, mu )
      a2 = p / ( 1.0d00 - p )
*     Find the value of t after which we can use Sidi acceleration
      sidit = fndst( p, phi, mu)

      if ( sidit .GT. 0.0d00 ) then
         tpt = 1
      else
         tpt = 0
      endif

 4000 if ( tpt .EQ. 1 ) then

*        Update
         n = n + 1
         oldt = tinfl
         deriv1 = deriv2

*        Find inflection points
         front = mu ** (1.0d00 - p ) / 
     &         ( phi * ( 1.0d00 - p ) )
         tinfl = front * dtan( dble(n) * pi * (1.0d00 - p)/p )

*        Find sign of derivative
         omega = datan( (1.0d00 - p) * phi * tinfl * 
     &                  mu**(p - 1.0d00) )
         top = omega * alpha
         bot = dcos(omega)**alpha
         Rek = lambda * ( dcos(top) / bot - 1.0d00 )
         Imk = lambda * dsin(top)/bot - tinfl * y
         deriv2 = mu * dcos( top ) / bot - y

         tpt = 0
*        test for turning point

         if ( ( deriv1 * deriv2 ) .LT. 0.0d00 ) then

            tpt = 1

*           Now find the zero, a turning point of Im k(t)
            olddt = dt
            t0 = ( oldt + tinfl ) / 2.0d00
            dt = DFsfzero(p, phi, y, oldt, tinfl,
     &                    t0, mu, DFdk, IMddk, ier )

*           Determine function values here
            oldft = ft
            call kt(p, phi, y, mu, dt, rl, ft)
*           The ft is the result we needed

*           Determine m values
            workvec1 = oldft / pi
            workvec2 = ft / pi

*           Find direction is which m's should go
            tmp = sign( ft-oldft, 1.0d00)
            if ( tmp .GT. 0.0d00 ) then
               mdirn = 1
            else
               mdirn = -1
            endif

*           Determine the m's
            if ( mdirn .GT. 0 ) then
               wv1 = ceil(workvec1)
               wv2 = myfloor(workvec2)
            else
               wv1 = myfloor(workvec1)
               wv2 = ceil(workvec2)
            endif

*           Set up bounds
            lobnd = olddt
            hibnd = dt

*           Now, work at each m
            do m = wv1, wv2, mdirn

*              Find the zeros
               zold = z1
               z0 = ( lobnd + hibnd ) / 2.0d00
               z1 = DFsfzero2( p, phi, y, lobnd, hibnd,
     &                        z0, mu,
     &                        DFintim, DFdk, m, ier)

*              Integrate
               call gaussq( DFfun, result, zold, z1,
     &                      p, phi, y, mu )

               area0 = area0 + result
               its1 = its1 + 1

*              Update
               lobnd = z1

            enddo

         endif

         goto 4000

      endif

*     Now do the cases where m is easy to find!
      its = 0
      goflag = 1

*     First, we evaluate up to sidit without acceleration
*     If sidit=0, we do one extra iteration anyway, since
*     sidi's algorithm cannot have a  xvec  being 0.
*
*     So we do this step for at least one iteration whatever.

      area1 = 0.0d00
      zold = z1

 4300 if ( goflag .EQ. 1 ) then

         its = its + 1

*        Determine m
         m = m - 1

*        Find zero
         lobnd = zold
         hibnd = zold + pi / y
         flo = DFintim( p, phi, y, lobnd, mu, m)
         fhi = DFintim( p, phi, y, hibnd, mu, m)

         boost = 1
*        boost enables us to get a region a bit quicker
 4550    if ( flo * fhi .GT. 0.0d00 ) then

            boost = boost + 1

*           Try harder for bounds
            delta = hibnd - lobnd
            lobnd = hibnd
            hibnd = hibnd + dble(boost) * delta / 2.0d00

            flo = DFintim( p, phi, y, lobnd, mu, m)
            fhi = DFintim( p, phi, y, hibnd, mu, m)

            goto 4550

         endif

         z0 = ( lobnd + hibnd ) / 2.0d00

         z1 = DFsfzero2( p, phi, y, lobnd, hibnd,
     &                  z0, mu,
     &                  DFintim, DFdk, m, ier)

*        Integrate
         call gaussq( DFfun, result, zold, z1,
     &                p, phi, y, mu )
         area1 = area1 + result

         its1 = its1 + 1

*        Update
         zold = z1
         goflag = 1

         if ( z1 .GT. sidit ) then
            goflag = 0
*           Time to start accelerating!
         endif

         goto 4300

      endif

*     area1 is now this area


*     Now start accelerating
      goflag = 1
      xvec(1) = z1
      its = 0
      w = 0d00

 4500 if ( goflag .EQ. 1 ) then

         its = its + 1

*        Determine m
         m = m - 1

*        Find zero
         lobnd = zold + 1.0d-05
         hibnd = zold + pi / y
         flo = DFintim( p, phi, y, lobnd, mu, m)
         fhi = DFintim( p, phi, y, hibnd, mu, m)

         boost = 1
*        boost enables us to get a region a bit quicker
 4350    if ( flo * fhi .GT. 0.0d00 ) then

            boost = boost + 1

*           Try harder for bounds
            delta = hibnd - lobnd
            lobnd = hibnd
            hibnd = hibnd + dble(boost) * delta / 2.0d00

            flo = DFintim( p, phi, y, lobnd, mu, m)
            fhi = DFintim( p, phi, y, hibnd, mu, m)

            go to 4350

         endif

         z0 = ( lobnd + hibnd ) / 2.0d00

         z1 = DFsfzero2( p, phi, y, lobnd, hibnd,
     &                  z0, mu, DFintim, DFdk, m, ier)

*        Integrate
         call gaussq( DFfun, result, zold, z1,
     &                p, phi, y, mu )
         area = area + result
*         verbose = 1
         if ( verbose .EQ. 1 ) then
*            call dblepr("    DFfun) = ", -1, DFfun, 1)
            call intpr("    result = ", -1, 22, 1)
            call intpr("    zold = ", -1, 22, 1)
            call intpr("    z1 = ", -1, 221, 1)
         endif

*        Accelerate
         xvec( its+1 ) = z1
         call accelerate( area, result, xvec, mmatrix,
     &          nmatrix,w, its, relerr, wold, sumarea,
     &          flag, verbose )

*        Update
         zold = z1
         goflag = 1
         if ( abs(relerr) .LT. aimrerr ) then
            goflag = 0
         endif

         goto 4500

      endif

*     Combine all the areas
      area = w + area1 + area0

      lambda = mu**(2.0d00 - p) / ( phi * (2.0d00 - p) )

      resulta = -1.0d00/(pi * ( 1.0d00 - dexp(-lambda) ))
     &               * area -
     &          dexp(-lambda) / 
     &          (2.0d00 * (1.0d00 - dexp(-lambda)))

      its = its + its1

      return

      end

****************************************************************
****************************************************************
      subroutine DFbigp( p, phi, y, mu, aimrerr, 
     &         resulta, maxit, ier, exitstatus, relerr, 
     &         its, verbose )
*     Calculates the DF in the case of distributions when p > 2

      double precision  p, phi, y,  pi, area, aimrerr,
     &          relerr, result, zero1, zero2, DFfun,
     &          DFintim, kddasht, flo, fhi,
     &          mmatrix(2, 200), nmatrix(2, 200),
     &          xvec(200), w, wold(3), area0, sumarea,
     &          DFdk, DFsfzero2, mu, DFsfzero,
     &          largest,smallest, resulta,
     &          area1, zero, zerofn, zerodfn, zstep2,
     &          kmax, tmax, zlo, zhi, zstep
      integer  m, its, ier, maxit, flag, allok, kmaxok, 
     &         mmax, firstm, exitstatus, verbose
      external  DFdk, DFsfzero2, DFintim, kddasht,
     &          DFsfzero, DFfun,zerofn, zerodfn

*     SET ACCURACY REQUIREMENTS
      largest = 1.0d30
      smallest = 1.0d-30

*SET M and N matrices, and other sidi things, to 0?
       write(*,*) "* IN DFbigp: y: * ", y

*     SET OTHER PARAMETERS
*      verbose = 1
      verbose = 0
      pi = dacos( -1.0d00 )
      area  = 0.0d00
      area0 = 0.0d00
      area1 = 0.0d00
      result = 0.0d00
      its = 0
      relerr = 1.0d00
      flag = 0
 
      wold(1) = 0.0d00
      wold(2) = 0.0d00
      wold(3) = 0.0d00

      if ( y .GE. mu ) then
*        In this case, Im(k) heads down straight away.
       write(*,*) "* Case: y >= mu", maxit

         kmax = 0.0d00
         mmax = -1
         tmax = 0.0d00
         m = -1

*        FIND ZEROS
         zero1 = 0.0d00
         
*        An approximation to the first zero:
         zero = pi / y

*        Now try to find this first zero:
         zlo = 0.0d00
         zhi = zero * 2.0d00

         if ( zhi .GT. largest/10.0d00 ) then
            allok = 0
            flo = 0.0d00
            fhi = 0.0d00
         else
            allok = 1
            flo = DFintim( p, phi, y, zlo, mu, m )
            fhi = DFintim( p, phi, y, zhi, mu, m )
         endif

 565     if ( ( allok .EQ. 1 ) .AND.
     &        (fhi * flo ) .GT. 0.0d00 ) then

            zlo = zhi
            zhi = zhi * 1.5d00

            flo = DFintim( p, phi, y, zlo, mu, m )
            fhi = DFintim( p, phi, y, zhi, mu, m )

            if ( zhi .GT. largest/10.0d00 ) allok = 0

            goto 565

         endif

         if ( zhi .GT. largest/10.0d00 ) allok = 0

         if ( allok .EQ. 0 ) then
            ier = -50
            result = 0.0d00

            return
         endif

         zero2 = DFsfzero2( p, phi, y, zlo, zhi, zero, 
     &               mu, DFintim, DFdk, m, ier )

         xvec(1) = zero2

         write(*,*) "    First zero found: :", zero2

*        special case: between 0 and first zero
         call gaussq( DFfun, area0, zero1, zero2, 
     &                p, phi, y, mu )
         write(*,*) "    First area found:", area0

*        Now do some more integrations and use sidi acceleration
  500    if (    ( ( its .LT. 4 ) .AND.
     &             ( flag .NE. 1 )
     &           )
     &        .OR.
     &           ( ( its .LT. maxit ) .AND.
     &             ( flag .NE. 1 ) .AND.
     &             ( abs(relerr) .GT. aimrerr )
     &           )
     &      ) then

*           get next zeros
         write(*,*) "    Get more zeros: : m:", m
            m = m - 1
            zstep = zero2 - zero1
            zero1 = zero2
            zlo = zero2 - 0.01d00 * zstep
            zhi = zero2 + 2.0d00 * zstep

            if ( zhi .GT. largest/10.0d00 ) then
               allok = 0
               flo = 0.0d00
               fhi = 0.0d00
            else
               allok = 1
               flo = DFintim( p, phi, y, zlo, mu, m )
               fhi = DFintim( p, phi, y, zhi, mu, m )
            endif

 765        if ( ( allok .EQ. 1 ) .AND.
     &           (fhi * flo ) .GT. 0.0d00 ) then

               zlo = zhi
               zhi = zhi * 1.5d00

               flo = DFintim( p, phi, y, zlo, mu, m )
               fhi = DFintim( p, phi, y, zhi, mu, m )

               if ( zhi .GT. largest/10.0d00 ) allok = 0

               goto 765

            endif

            if ( zhi .GT. largest/10.0d00 ) allok = 0

            if ( allok .EQ. 0 ) then
               ier = -50
               result = 0.0d00
               return
            endif

            zero2 = DFsfzero2( p, phi, y, zlo, zhi, zero, 
     &                  mu, DFintim, DFdk, m, ier )

*           integrate between zeros
            call gaussq( DFfun, result, zero1, zero2,
     &                     p, phi, y, mu )
     
*           Update iteration count
            its = its + 1

*           accelerate convergence of infinite sequence
            xvec( its+1 ) = zero2

            call accelerate( area, result, xvec, mmatrix,
     &           nmatrix, w, its, relerr, wold, sumarea, 
     &           flag, verbose )

            relerr = ( abs( w - wold(1) ) + 
     &                 abs( ( w - wold(2) ) ) )
     &               / (area0 + w)

            area = area + result

            goto 500

         endif

         if ( ( its .GE.  maxit ) .AND.
     &        ( abs(relerr) .GT. aimrerr) ) then
            ier = -40
         endif

         if ( flag .EQ. 1 ) then
            ier = -70
         endif

         result = area0 + w

*        Now, the very first integration has not been counted
*        (since that can foul up the Sidi acceleration iteration count)
*        so update now
         its = its + 1
         
      else
*        i.e.;  if ( y .LT. mu) 
*        In this case, Im(k) may head *up* before going to  -infinity
       write(*,*) "* Case: y < mu", maxit

*        FIND k_max AND t_max
         kmaxok = 1
        write(*,*) "  * Find kmax: call DFfindkmax", maxit

         call DFfindkmax(p, phi, y, mu, 
     &            kmax, tmax, mmax, ier)
         write(*,*) "    KMAX found: ", kmax
         write(*,*) "    TMAX found: ", tmax
         write(*,*) "    MMAX found: ", mmax

         if ( ier .NE. 0 ) then
             kmaxok = 0
         endif

*        IF KMAX < pi/2 AND NO CONVERGENCE?

         if ( kmax .LT. pi ) then
*           In this case, the upward trend doesn't reach pi/2.  Thus,
*           the first zero is where Im(k) first crosses the t/x-axis
*           again; that is, at m=0.
         write(*,*) "    KMAX less than pi/2, but upward: ", kmax

            if ( ier .EQ. -80 ) then
               result = 0.0d00
               return
            endif

            m = 0

*           FIND ZEROS
            zero1 = 0.0d00
            zero = tmax + ( pi / y )
            write(*,*) "    First zero, initial estimate: t=", zero

*           BOUNDS ON OTHER ZERO:
            zlo = tmax
            zhi = zero * 1.2d00

            if ( zhi .GT. largest/10.0d00 ) then
               allok = 0
               flo = 0.0d00
               fhi = 0.0d00
            else
               allok = 1
               flo = DFintim(p, phi, y, zlo, mu, m)
               fhi = DFintim(p, phi, y, zhi, mu, m)
            endif

 1565       if ( (allok .EQ. 1 ) .AND.
     &            ( (fhi * flo ) .GT. 0.0d00 ) ) then

               zlo = zhi
               zhi = zhi * 1.5d00

               flo = DFintim( p, phi, y, zlo, mu, m )
               fhi = DFintim( p, phi, y, zhi, mu, m )

               if ( zhi .GT. largest/10.0d000 ) allok = 0

               goto 1565

            endif

            if ( zhi .GT. largest/10.0d00 ) allok = 0

            if ( allok .EQ. 0 ) then
               ier = -50
               result = 0.0d00

               return
            endif

        write(*,*) "ABOUT TO CALL DFsfzero2... zlo:", zlo
        write(*,*) "ABOUT TO CALL DFsfzero2... zhi:", zhi
            zero2 = DFsfzero2( p, phi, y, zlo, zhi, zero,
     &                  mu, DFintim, DFdk, m, ier )
        write(*,*) "END CALL DFsfzero2...zero1:", zero1
        write(*,*) "END CALL DFsfzero2...zero2:", zero2

            xvec(1) = zero2

*           integrate between zeros
        write(*,*) ">>>>> ABOUT TO integrate: p", p
        write(*,*) ">>>>> ABOUT TO integrate: zero1", zero1
        write(*,*) ">>>>> ABOUT TO integrate: zero2", zero2
            call gaussq( DFfun, area0, zero1, zero2, 
     &                   p, phi, y, mu )
        write(*,*) "      DONE: : area0", area0

  600       if (    ( ( its .LT. 4 ) .AND.
     &                 ( flag .NE. 1 )
     &               )
     &            .OR.
     &               ( ( its .LT. maxit ) .AND.
     &                 ( flag .NE. 1 ) .AND.
     &                 ( abs(relerr) .GT. aimrerr )
     &               ) ) then

*              get next zeros
               m = m - 1

        write(*,*) "      Stepping sideways...: p", p
               zstep = ( zero2 - zero1 )
               zero1 = zero2
               zlo = zero2 - 0.01d00 * zstep
               zhi = zero2 + 2.0d00 * zstep

               if ( zhi .GT. largest/10.d00 ) then
                  allok = 0
                  flo = 0.0d00
                  fhi = 0.0d00
               else
                  allok = 1
        write(*,*) "      * Calling DFintim again: p", p
                  flo = DFintim( p, phi, y, zlo, mu, m )
        write(*,*) "      * Called DFintim again: flo", flo
                  fhi = DFintim( p, phi, y, zhi, mu, m )
        write(*,*) "      * Called DFintim again: fhi", fhi
               endif

 1665          if ( ( allok .EQ. 1 ) .AND.
     &              (fhi * flo ) .GT. 0.0d00 ) then

                   zlo = zhi
                   zhi = zhi + zstep

                  flo = DFintim( p, phi, y, zlo, mu, m )
                  fhi = DFintim( p, phi, y, zhi, mu, m )

                  if ( zhi .GT. largest/10.0d000 ) then
                     allok = 0
                  endif

                  goto 1665

               endif

        write(*,*) "      FEELING GROOVY...: p", p

               if ( zhi .GT. largest/10.d00 ) allok = 0

               if ( allok .EQ. 0 ) then
                  ier = -50
                  result = 0.0d00

                  return

               endif

*              Approximate with a linear interpolation
               zero = zlo - flo * ( zhi - zlo ) / 
     &                  ( fhi - flo )

               zero2 = DFsfzero2( p, phi, y, zlo, zhi, 
     &                         zero, mu, DFintim, DFdk, 
     &                         m, ier )

*              integrate between zeros
               call gaussq( DFfun, result, zero1, zero2,
     &                        p, phi, y, mu )

*              Update iteration count
               its = its + 1
               
*              accelerate convergence of infinite sequence
               xvec( its+1 ) = zero2

               call accelerate( area, result, xvec, mmatrix, 
     &            nmatrix, w, its, relerr, wold, 
     &            sumarea, flag, verbose )

               area = area + result

               goto 600

            endif

            if ( ( its .GE.  maxit ) .AND.
     &           ( abs(relerr) .GT. aimrerr) ) then
               ier = -40
            endif

            if ( flag .EQ. 1 ) then
               ier = -70
            endif

            result = area0 + w
            
*           Now, the very first integration has not been counted
*           (since that can foul up the Sidi acceleration iteration count)
*           so update now
            its = its + 1

         else
*           that is:   case where kmax >= pi
*           In this case, the upward trend is goes above  pi, and so
*           the first zero will be at  m=1.
         write(*,*) "    KMAX bigger than pi: ", kmax

*           Now, kmax may not have been found accurately.  IF, however,
*           the corresponding max > maxit, it won't matter a great deal
*           and we can proceed.  If not, accuracy cannot be ensured
*           unless the maximum  m  used is less than maxit.  So we
*           test  ier.

            if ( ier .EQ. -80 ) then
               result = 0.0d00
               return
            endif

            wold(1) = 0.0d00
            wold(2) = 0.0d00
            wold(3) = 0.0d00

*           FIND ZEROS
            zero1 = 0.0d00
            zero = pi / ( mu - y )
            m = 1
            firstm = 1

            zlo = smallest
            zhi = tmax

            if ( zhi .GT. largest/10.d00 ) then
              allok = 0
              flo = 0.0d00
              fhi = 0.0d00
            else
               allok = 1
               flo = DFintim( p, phi, y, zlo, mu, m )
               fhi = DFintim( p, phi, y, zhi, mu, m )
            endif

            zstep = zhi - zlo

 2565       if ( ( allok .EQ. 1 ) .AND.
     &           (fhi * flo ) .GT. 0.0d00 ) then


               zlo = zhi
               zhi = zhi + 0.1d00 * zstep

               flo = DFintim( p, phi, y, zlo, mu, m )
               fhi = DFintim( p, phi, y, zhi, mu, m )

               if ( zhi .GT. largest / 10.0d00 ) then
                  allok = 0
               endif

               goto 2565

            endif

            if ( zhi .GT. largest/10.d00 ) allok = 0

            if ( allok .EQ. 0 ) then
               ier = -50
               result = 0.0d00

               return
            endif

            zero2 = DFsfzero2( p, phi, y, zlo, zhi, zero, 
     &                  mu, DFintim, DFdk, m, ier )

            xvec( 1 ) = zero2

            call gaussq( DFfun, area0, zero1, zero2, 
     &                   p, phi, y, mu )

****NOW INTEGRATE UP TO  tmax  WITHOUT ACCELERATION???
*   This seems to make sense to ensure that Sidi's method converges, but
*   there will be cases where we will take a loooonnnggg time to reach
*   tmax, and we will `never' use Sidi's method.

            zstep2 = zero2-zero1

  700       if (    ( ( its .LT. 4 ) .AND.
     &                ( flag .NE. 1 )
     &              )
     &           .OR.
     &              ( ( its .LT. maxit ) .AND.
     &                ( flag .NE. 1 ) .AND.
     &                ( abs(relerr) .GT. aimrerr )
     &              ) ) then

*              get next zeros

               zlo = zero2 - 1.0d-05 * zstep2
               zhi = zero2 + 2.0d00 * zstep2

               zero1 = zero2

*              FIND THE NEXT VALUE OF  m
               call nextm( tmax, mmax, zero2, m, firstm,
     &                     zlo, zhi, zero )

               if ( zhi .GT. largest/10.d00 ) then
                  allok = 0
                  flo = 0.0d00
                  fhi = 0.0d00
               else
                  allok = 1
                  flo = DFintim( p, phi, y, zlo, mu, m )
                  fhi = DFintim( p, phi, y, zhi, mu, m )
               endif

 2665          if ( ( allok .EQ. 1 ) .AND.
     &              (fhi * flo ) .GT. 0.0d00 ) then

                  zstep = ( zhi - zlo )
                  zlo = zhi
                  zhi = zhi + 0.2d00*zstep2

                  flo = DFintim( p, phi, y, zlo, mu, m )
                  fhi = DFintim( p, phi, y, zhi, mu, m )

                  if ( zhi .GT. largest/10.0d00 ) then
                     allok = 0
                  endif

                  goto 2665

               endif

               if ( zhi .GT. largest/10.0d00 ) allok = 0

               if ( allok .EQ. 0 ) then
                  ier = -50
                  result = 0.0d00

                  return
               endif

               zero2 = DFsfzero2( p, phi, y, zlo, zhi,
     &                         zero, mu, DFintim, 
     &                        DFdk, m, ier )

               call gaussq( DFfun, result, zero1, zero2,
     &                        p, phi, y, mu )
     
*              Update iteration count
               its = its + 1
               
*              accelerate convergence of infinite sequence
               xvec( its+1 ) = zero2
               call accelerate( area, result, xvec, mmatrix,
     &                   nmatrix, w, its, relerr, wold, 
     &                   sumarea, flag, verbose )

               area = area + result

               goto 700

            endif

            if ( ( its .GE.  maxit ) .AND.
     &           ( abs(relerr) .GT. aimrerr) ) then
               ier = -40
            endif

            if ( flag .EQ. 1 ) then
               ier = -70
            endif

            if ( kmaxok .EQ. 0 ) then
*              IF finding kmax didn't converge...

               if ( mmax .LT. maxit ) kmaxok = 1
*              All should be OK if mmax is less than maximum
*              that mmax can reach

               if ( m .LT. mmax-1 )  kmaxok = 1
*              All should be OK if greatest value of m used
*              is less than the `turning' m value.

            endif

            if ( kmaxok .EQ. 0 )  then
               ier = -60
            endif

            result = area0 + w
            
*           Now, the very first integration has not been counted
*           (since that can foul up the Sidi acceleration iteration count)
*           so update now
            its = its + 1
         endif
      endif

        write(*,*) "NEAR END DFbigp", maxit

**     We have integrated to find  \int_0^{\infty}.  The integral
**     required actually goes from -infty to +infty, but is
**     symmetric about the y-axis, so the integral is _twice_ the result
**     obtained above.

      resulta = -result / pi

*     Determine the error
*     (Keep in this order so the most important aspect is returned)
*     Note also that if we don't use Sidi, and w=0 as set initially,
*     We have good relative error, so that line should be OK.
      if ( abs(w) .LT. aimrerr ) then
         exitstatus = -1
      else
         exitstatus = -10
      endif
      if ( abs(relerr) .LT. aimrerr ) exitstatus = 1


*************SIDI-T STUFF IF WE FIND WE NEED IT************************
**     FIND THE UPPER LIMIT OF t so that after this t, use Sidi.
*      sidit = fndsidit( p, mu, phi, y )
*      print *,'SIDI-T = ',sidit
*************SIDI-T STUFF IF WE FIND WE NEED IT************************

        write(*,*) "END DFbigp", maxit
      return

      end

******************************************************************
****************************************************************
      subroutine DFapproxz( p, phi, y, mu, aimrerr, result,
     &                       maxit, ier, exitstatus, relerr, its )
*     Calculates the DF for distributions when  p > 2, using APPROX Sidi acceleration

      double precision  p, phi, y,  pi, area, aimrerr,
     &          relerr, result, zero1, zero2, DFfun,
     &          DFintim, kddasht, DFsfzero, DFfun2,
     &          mmatrix(2, 200), nmatrix(2, 200),
     &          xvec(200), w, wold(3), area0, sumarea,
     &          DFdk, DFsfzero2, mu,
     &          largest, smallest, kmax, tmax,
     &          area1, zerofn, zerodfn
      integer  its, ier, maxit, flag, 
     &         mmax, exitstatus, verbose,
     &         itsidi
      external  DFdk, DFsfzero2, DFintim, kddasht,
     &          DFsfzero, DFfun,zerofn, zerodfn,
     &          DFfun2

      largest = 1.0d30
      smallest = 1.0d-30

*     SET OTHER PARAMETERS
      pi = dacos( -1.0d00 )
      area = 0.0d00
      area0 = 0.0d00
      area1 = 0.0d00
      result = 0.0d00
      its = 0
      itsidi = 0
      relerr = 1.0d00
      flag = 0
      verbose = 0

      wold(1) = 0.0d00
      wold(2) = 0.0d00
      wold(3) = 0.0d00

      if ( p .GT. 2.0d00 ) then
*        Find kmax
         call DFfindkmax(p, phi, y, mu, 
     &            kmax, tmax, mmax, ier)

*        While t < tmax, do not use Sidi acceleration

         zero2 = 0.0d00

 400     if ( zero2 .LE. tmax ) then

*           get next zero: jump the zero by pi/y
            zero1 = zero2
            zero2 = zero2 + (pi/y)

            call gaussq( DFfun, result, zero1, zero2,
     &                   p, phi, y, mu )
            area0 = area0 + result

            its = its + 1

            goto 400

         endif

      else

         zero1 = 0.0d00
         zero2 = pi / y
         xvec(1) = zero2

         call gaussq( DFfun2, area0, zero1, zero2,
     &                p, phi, y, mu )
         its = its + 1

      endif

*     Now for Sidi acceleration
*     itsidi = itsidi + 1
      xvec(1) = zero2

*     Now do some more integrations and use sidi acceleration
  500 if (    ( ( itsidi .LT. 4 ) .AND.
     &          ( flag .NE. 1 )
     &        )
     &     .OR.
     &        ( ( itsidi .LT. maxit ) .AND.
     &          ( flag .NE. 1 ) .AND.
     &          ( abs(relerr) .GT. aimrerr )
     &        )
     &   ) then

*        get next zeros: jump by pi/y
         zero1 = zero2
         zero2 = zero2 + ( pi / y)

*        integrate between zeros
         if ( p .GT. 2.0d00 ) then
           call gaussq( DFfun, result, zero1, zero2,
     &                  p, phi, y, mu )
         else
           call gaussq( DFfun2, result, zero1, zero2,
     &                  p, phi, y, mu )
         endif

*        Update interation count
         its = its + 1
         itsidi = itsidi + 1

*        accelerate convergence of infinite sequence
         xvec( itsidi + 1 ) = zero2

         call accelerate( area, result, xvec, mmatrix,
     &        nmatrix, w, itsidi, relerr, wold, sumarea, 
     &        flag, verbose )

         relerr = ( abs( w - wold(1) ) + 
     &              abs( ( w - wold(2) ) ) )
     &            / (area0 + w )

         area = area + result

         goto 500

      endif

      result = -(area + area0) / pi

**     We have integrated to find  \int_0^{\infty}.  The integral
**     required actually goes from -infty to +infty, but is
**     symmetric about the y-axis, so the integral is _twice_ the result
**     obtained above.

*     Determine the error
*     (Keep in this order so the most important aspect is returned)
*     Note also that if we don't use Sidi, and w=0 as set initially,
*     We have good relative error, so that line should be OK.
      if ( abs(w) .LT. aimrerr ) then
         exitstatus = -1
      else
         exitstatus = -10
      endif
      if ( abs(relerr) .LT. aimrerr ) exitstatus = 1


*************SIDI-T STUFF IF WE FIND WE NEED IT************************
**     FIND THE UPPER LIMIT OF t so that after this t, use Sidi.
*      sidit = fndsidit( p, mu, phi, y )
*      print *,'SIDI-T = ',sidit
*************SIDI-T STUFF IF WE FIND WE NEED IT************************

      return

      end

****************************************************************
****************************************************************
      subroutine DFfindkmax(p, phi, y, mu,
     &                      kmax, tmax, mmax, ier)
*     Finds  k_max and t_max
*     We solve Im{k'(t)}=0 using Newton's method.
*
*     IN:  p, phi, y, maxit, mu
*     OUT: kmax, tmax, mmax, ier

      double precision  kmax, tmax, kddasht,
     &          delta, z, p, largest, fhi, flo,
     &          phi, y, pi, front, mu, rl, DFddk,
     &          DFsfzero, zhi, zlo, DFdk, dpmmax
      integer  mmax, ier, allok, lrgint
      external  DFdk, DFddk, kddasht

* MAJOR VARIABLES:
*    kmax      : the maximum value of k {we have sin( Im k(t) ) }
*    tmax      : the t-value where the maximum occurs
*    mmax      : the maximum value of  m  we will have
*                (where sin( Im k(t) ) = m\pi )

      pi = dacos( -1.0d00 )
      delta = 1.0d00
      ier = 0
      allok = 1
      largest = 1.0d30
      lrgint = 100000000

*     A good starting point is sometime crucial, so we spend a
*     little time finding a decent one.
*     We try the point of inflection and the approximation for
*     t  large (which can happen, for example, when y is very small).
*     We then choose the point for which the derivative is closest
*     to zero and still positive (ie on the left of the maximum).

      front = mu ** ( 1.0d00 - p ) / 
     &         ( phi * (1.0d00 - p ) )

      z = front * dtan( pi/2.0d00 * (1.0d00 - p) /
     &                 ( 2.0d00*p - 1.0d00 ) )
      z = abs( z )

      zlo = 0.0d00
      zhi = z
      write(*,*) "    - IN DFfindkmax: STARTING TO FIND KMAX"
      write(*,*) "      Starting with zlo:", zlo
      write(*,*) "      Starting with zhi:", zhi

      flo = DFdk(p, phi, y, mu, zlo )
      fhi = DFdk(p, phi, y, mu, zhi )
      write(*,*) "      And so, flo:", flo
      write(*,*) "      And so, fhi:", fhi
      write(*,*) "      Thus, flo * fhi:", flo * fhi

*     Now we ensure the zero is bounded; if not, we venture further out
 565  if ( ( allok .EQ. 1 ) .AND.
     &     ( fhi * flo .GT. 0.d00 ) ) then
      write(*,*) "      So not bounded. So update:", flo * fhi

         zlo = zhi
         zhi = 1.3d00 * zhi + 1.0d-01

      write(*,*) "      Update zlo:", zlo
      write(*,*) "      Update zhi:", zhi
         flo = DFdk(p, phi, y, mu, zlo )
         fhi = DFdk(p, phi, y, mu, zhi )
         if ( zhi .GT. largest/10.d00 ) allok = 0
      write(*,*) "      And update, flo:", flo
      write(*,*) "      And update, fhi:", fhi
      write(*,*) "      Thus, update flo * fhi:", flo * fhi

         goto 565

      endif
      write(*,*) "    > BOUNDED at last:", flo * fhi


      if ( allok .EQ. 0 ) then
         ier = -80
         z = 0.0d00
         kmax = 0.0d00
         mmax = 0
         tmax = 0.0d00
         return
      else
         flo = DFdk(p, phi, y, mu, zlo )
         fhi = DFdk(p, phi, y, mu, zhi )

*        This is linear interpolation:
         z = zlo - flo * ( zhi - zlo ) / ( fhi - flo )
      write(*,*) "      - Make a linear interpolation; z:", z
      write(*,*) "      - Find kmax with DFsfzero, start z:", z
      write(*,*) "      - ---(top)------------------------", z
      write(*,*) "        - call DFsfzero fun  is DFdk", zlo
      write(*,*) "        -              dfun  is kddasht", zhi
         z = DFsfzero( p, phi, y, zlo, zhi, z, mu,
     &                 DFdk, DFddk, ier )
      write(*,*) "      - ---(bot)------------------------", z
      write(*,*) "      - Found the zero at ", z
      endif

      write(*,*) "      - So we can start the search for kmax:", flo
      write(*,*) "      -   flo:", flo
      write(*,*) "      -   fhi:", fhi

*     We proceed even if ier .NE. 0 since the calling function
*     may be happy about it.  Eg, if the corresponding  mmax
*     is larger than  maxit, it won't matter if  kmax  isn't
*     found to any accuracy, provided  mmax>maxit.

      tmax = z

*     Now we find the value of  kmax  at  tmax:
      call kt( p, phi, y, mu, tmax, rl, kmax )
      write(*,*) "      - ...and FOUND KMAX:", kmax
      write(*,*) "           at TMAX:", tmax

*     Now, we can have real troubles here if  p  gets large
*     since them psi= datan( (1.0d00 - p) * x * phi ) gets
*     really close to -pi/2.  I'm not sure how to best deal with
*     this, but a side-effect is sometimes that kmax<0, which it
*     shouldn't be.  In any case, kmax<0 means PROBLEMS.
*
*     What bothers me is how to detect problems when there *are* problems
*     but  kmax  doesn't become negative...?

      if ( kmax .LT. 0d00 ) then
         kmax = abs(kmax)
         mmax = lrgint
         allok = 0
      else
         dpmmax = kmax / pi

         if ( dpmmax .GT. dble( lrgint ) ) then
            mmax = lrgint
            allok = 0
         else
            mmax = int( dpmmax )
         endif
      endif
        write(*,*) "*   Success:  KMAX FOUND:", kmax
        write(*,*) "*             MMAX FOUND:", mmax

      return
      end

****************************************************************
****************************************************************
      double precision function DFfun(p, phi, y, mu, x)
*     A function to be numerically integrated in the DF.
*     Note that
*        lim (n->infty) exp( Re k) = exp( -lambda).
*     DFfun2  is used for the conditional CDF for 1 < p < 2; DFfun  for p > 2.
*
*     IN:  p, phi, y, mu, x
*     OUT: DFfun

      double precision  x, p, phi, y, mu, lambda,
     &                  calclambda, rl, im

* MAJOR VARIABLES:
*   p          : the index in the variance function, V(mu) = phi * mu^p
*   phi        : the dispersion parameter
*   y          : the point at which the DF is to be evaluated
*   mu         : the mean value
*   x          : the internal variable over which to integrate in this function
*   rl         : the real part of the cgf
*   im         : the imaginary part of the cgf
*   lambda     : P(Y = 0) = exp( -lambda ) when 1 < p < 2
 

      lambda = calclambda( p, phi, mu )

      if ( x .EQ. 0.0d00 ) then
         DFfun = mu - y
      else
         call kt(p, phi, y, mu, x, rl, im)
         DFfun = dexp( rl ) * dsin( im ) / x
      endif

      return
      end

*******************************************************************
****************************************************************
      double precision function DFfun2(p, phi, y, mu, x)
*     A function to be numerically integrated in DF
*     using the conditional DF.  Note that
*        lim (n->infty) exp( Re k) = exp( -lambda).
*     DFfun2  is used for the conditional CDF for 1 < p < 2; DFfun  for p > 2.
*
*     IN:  p, phi, y, mu, x
*     OUT: DFfun2

      double precision  x, p, phi, y, rl, im, mu,
     &                  calclambda, lambda

* MAJOR VARIABLES:
*   p          : the index in the variance function, V(mu) = phi * mu^p
*   phi        : the dispersion parameter
*   y          : the point at which the DF is to be evaluated
*   mu         : the mean value
*   x          : the internal variable over which to integrate in this function
*   rl         : the real part of the cgf
*   im         : the imaginary part of the cgf
*

      lambda = calclambda( p, phi, mu )

      if ( x .EQ. 0.0d00 ) then
         DFfun2 = ( mu - y ) + y * exp( -lambda )
      else
         call kt(p, phi, y, mu, x, rl, im)

         DFfun2 = dexp( rl ) * dsin( im ) + 
     &           dexp( -lambda ) * dsin( x*y )
         DFfun2 = DFfun2 / x
      endif

*     Now, we use the conditional DF so we apply the tranform:
      DFfun2 = DFfun2 / ( 1.0d00 - exp( -lambda ) )

      return
      end

*******************************************************************
*******************************************************************
      double precision function DFdk(p, phi, y, mu, x)
*     *     Evaluates the Im{ k'(t) } function
*
*     IN:  p, phi, y, mu, x
*     OUT: DFdk

      double precision  p, phi, y, mu, x, rl, tmp

      call kdasht( p, phi, y, mu, x, rl, tmp )
      DFdk = tmp
      
      return
      end

*******************************************************************
*******************************************************************
      double precision function DFddk(p, phi, y, mu, x)
*     *     Evaluates the Im{ k''(t) } function
*
*     IN:  p, phi, y, mu, x
*     OUT: DFddk

      double precision  p, phi, y, mu, x, rl, tmp

      call kddasht( p, phi, y, mu, x, rl, tmp )
      DFddk = tmp
      
      return
      end

*******************************************************************
******************************************************************
      double precision function DFsfzero( p, phi, y, x1, 
     &            x2, x0, mu, fun, dfun, ier )
*     Uses a modified Newton's Method to find a root between
*     x1 and x2.  Used when functions called doesn't need
*     an  m  input; otherwise, use DFsfzero2.
*
*     IN:  p, phi, y, x1, x2, x0, mu, acc, fun, dfun
*     OUT: DFsfzero

      double precision  df, dx, dxold, f, fh, fl, temp, 
     &            xh, xl, x1, x2, fun, dfun, y, mu,
     &            p, phi, x0
      integer  j, maxit, ier
      external  fun, dfun

      write(*,*) "        * IN: DFsfzero; p=", p
      write(*,*) "        * First, use  fun  (ie DFdk) at x", x0

*     SET PARAMETERS
      maxit = 100
      ier = 0

      fl = fun(p, phi, y, mu, x1)
      fh = fun(p, phi, y, mu, x2)
      write(*,*) "        * xl:", x1
      write(*,*) "        * fl:", fl
      write(*,*) "        * xh:", x2
      write(*,*) "        * fh:", fh

      if ( fl .EQ. 0.0d00 ) then
         DFsfzero = x1
         return
      elseif ( fh .EQ. 0.0d00 ) then
         DFsfzero = x2
         return
      elseif ( fl .LT. 0.0d00 ) then
         xl = x1
         xh = x2
      else
         xl = x2
         xh = x1
      endif      
      write(*,*) "        ------", x1
      write(*,*) "        * xl:", x1
      write(*,*) "        * fl:", fl
      write(*,*) "        * xh:", x2
      write(*,*) "        * fh:", fh

      if ( ( x0 .GT. xl ) .AND. ( x0 .LT. xh ) ) then
         DFsfzero = x0
      else
         DFsfzero = ( xl + xh ) / 2.0d00
      endif
      dxold = abs( x2 - x1 )
      dx = dxold

      f  =  fun( p, phi, y, mu, DFsfzero )
      df = dfun( p, phi, y, mu, DFsfzero )

      write(*,*) "        ------", x1
      write(*,*) "        * xl:", x1
      write(*,*) "        * fl:", fl
      write(*,*) "        * xh:", x2
      write(*,*) "        * fh:", fh
      write(*,*) "Not sure what next bit does...", fh

* What is this doing??
      do j = 1, maxit
      
         write(*,*) "     >> ITERATING: j = ", j

         if ( ( (DFsfzero-xh)*df-f)*((DFsfzero-xl)*df-f)
     &            .GT.0.0d00
     &                .OR.
     &        abs(2.0d00*f) .GT. abs( dxold*df) ) then

            dxold = dx
            dx = 0.5d00 * ( xh - xl )
            DFsfzero = xl + dx

            if ( xl .EQ. DFsfzero ) then
               return
            endif
         else
            dxold = dx
            dx = f/df
            temp = DFsfzero
            DFsfzero = DFsfzero - dx
            if ( temp .EQ. DFsfzero ) then
               return

            endif
         endif
         
         if ( abs( dx ) .LT. 1.0d-11 ) then
            return
         endif

         f  =  fun( p, phi, y, mu, DFsfzero )
         df = dfun( p, phi, y, mu, DFsfzero )

         if ( f .LT. 0.0d00 ) then
            xl = DFsfzero
         else
            xh = DFsfzero
         endif

      enddo

*     If we get this far, we haven't returned and so there is an error:
      ier = -20

      return
      end

****************************************************************
****************************************************************
      double precision function DFsfzero2( p, phi, y, x1, 
     &            x2, x0, mu, fun, dfun, m, ier )
*     A modified Newton's Method to find a root between x1 and x2 to 
*     find kmax.  Used when functions called need an  m  input; 
*     otherwise, use DFsfzero.
*
*     IN:  p, phi, y, x1, x2, x0, mu, acc, fun, dfun, m
*     OUT: DFsfzero2

      double precision  df, dx, dxold, f, fh, fl, temp, 
     &                  xh, xl, x1, x2, fun, dfun,
     &                  mu, p, phi, x0, y
      integer  j, maxit, ier, m
      external  fun, dfun
        write(*,*) "IN DFsfzero2", p

*     SET PARAMETERS
      maxit = 100
      ier = 0

        write(*,*) "ABOUT to call fn 1", p
      fl = fun(p, phi, y, x1, mu, m)
      fh = fun(p, phi, y, x2, mu, m)
        write(*,*) "END to call fn 1", fh
        write(*,*) "fl 1", fl
        write(*,*) "fh 1", fh

      if ( fl .EQ. 0.0d00 ) then
         DFsfzero2 = x1
         return
      elseif ( fh .EQ. 0.0d00 ) then
         DFsfzero2 = x2
         return
      elseif ( fl .LT. 0.0d00 ) then
         xl = x1
         xh = x2
      else
         xl = x2
         xh = x1
      endif

      if ( ( x0 .GT. xl ) .AND. ( x0 .LT. xh ) ) then
         DFsfzero2 = x0
      else
         DFsfzero2 = ( xl + xh ) / 2.0d00
      endif

      dxold = abs( x2 - x1 )
      dx = dxold

        write(*,*) "ABOUT to call fn 2", p
      f  =  fun( p, phi, y, DFsfzero2, mu, m )
      df = dfun( p, phi, y, mu, DFsfzero2 )
        write(*,*) "END to call fn 2", p
        write(*,*) "fl 2", fl
        write(*,*) "fh 2", fh

      do j = 1, maxit

         if ( ( (DFsfzero2 - xh) * df - f)*
     &            ((DFsfzero2 - xl) * df - f) .GT. 0.0d00
     &                .OR.
     &        abs(2.0d00 * f) .GT. abs( dxold * df) ) then

            dxold = dx
            dx = 0.5d00 * ( xh - xl )
            DFsfzero2 = xl + dx

            if ( xl .EQ. DFsfzero2 ) then
               return
            endif

         else
            dxold = dx
            dx = f/df
            temp = DFsfzero2
            DFsfzero2 = DFsfzero2 - dx
            if ( temp .EQ. DFsfzero2 ) then
               return
            endif
         endif

         if ( abs( dx ) .LT. 1.0d-11 ) then
            return
         endif

        write(*,*) ">>> ABOUT to call  fn  3", p
         f  =  fun( p, phi, y, DFsfzero2, mu, m )
        write(*,*) ">>> ABOUT to call  dfn  3", p
         df = dfun( p, phi, y, mu, DFsfzero2 )
        write(*,*) "END to call fn 3; f=", f
        write(*,*) "END to call fn 3; df=", df

         if ( f .LT. 0.0d00 ) then
            xl = DFsfzero2
         else
            xh = DFsfzero2
         endif

      enddo

*     If we get this far, we haven't returned and so there is an error:
      ier = -20

      return
      end

*******************************************************************
*******************************************************************
      double precision function IMddk(p, phi, mu, x)
*     Evaluates the Im{ k''(t) } function
*
*     IN:  p, phi, y, mu, x
*     OUT: IMddk

      double precision  p, phi, mu, x, rl, tmp

      write(*,*) "        * In IMddk", x

      call kddasht( p, phi, mu, x, rl, tmp )
      IMddk = tmp

      return
      end

*******************************************************************
*******************************************************************
      double precision function fndst( p, phi, mu)
***
      double precision  p, phi, mu, front, pi
      integer  mmax
      external  calclambda

      write(*,*) "        * In fndst", phi

      pi = dacos( -1.0d00 )
      if ( abs( p - 1.5d00 ) .LT. 1.0d-02 ) then
         fndst = 0.0d00
      else
*        Find the largest m for which there are turning points in exp( Re k)
         mmax = int( 1.0d00 / ( 2.0d00 * (1.0d00 - p) ) )

*        The t this correpsonds to is...
         front = mu**(1.0d00 - p) / ( phi * ( 1.0d00 - p ) )
         fndst = front * dtan( dble(mmax) * 
     &            pi * (1.0d00 - p) )
         fndst = abs( fndst )

      endif

      return
      end

*******************************************************************
*******************************************************************
      double precision function DFintim( p, phi, y, 
     &                                    x, mu, m )

*     The imaginary part for zeroing the integrand.
*
*     IN:  p, phi, y, x, mu, m
*     OUT: DFintim

      double precision  x, p, phi, y, pi, im, rl, mu
      integer  m

* MAJOR VARIABLES:
*   rl         : the real part of the cgf
*   im         : the imaginary part of the cgf

      pi = dacos( -1.0d00 )

      write(*,*) "* In DFintim; x:", x
      
      if ( x .EQ. 0.0d00 ) then
         DFintim = -dble(m) * pi
      else
         call kt( p, phi, y, mu, x, rl, im )
         DFintim = -dble(m) * pi + im
      endif
      write(*,*) "* OUT DFintim:", DFintim
      
      return
      end

******************************************************************


